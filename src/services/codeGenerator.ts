// src/services/codeGenerator.ts
import { AnalysisMode, CodeTemplateType } from './AnalysisMode';
import { HarEntry, DetectedToken } from './TokenDetector';

class CodeGenerationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CodeGenerationError';
  }
}

interface CodeGenerationOptions {
  includeAnalysisModeMetadata: boolean;
  optimizeForContext: boolean;
  generateValidationBlocks: boolean;
}

// Inferred template structure
interface CodeTemplate {
    generateRequestBlock(entry: HarEntry): string;
    generateParseBlock(token: DetectedToken): string;
    generateKeyCheckBlock(entries: HarEntry[]): string;
}

// Basic Template Implementations
class GenericRequestTemplate {
    generateRequestBlock(entry: HarEntry): string {
        const { request } = entry;
        let block = `BLOCK:Request "${request.method} ${new URL(request.url).pathname}"\n`;
        block += `  method = ${request.method}\n`;
        block += `  url = "${request.url}"\n`;
        if (request.postData?.text) {
            block += `  content = "${request.postData.text}"\n`;
        }
        block += `ENDBLOCK\n\n`;
        return block;
    }
}

// Main Generator Class
export class ContextualCodeGenerator {
  constructor(
    private readonly analysisMode: AnalysisMode,
    private readonly templateType: CodeTemplateType
  ) {}

  generateOptimizedLoliCode(
    criticalPath: HarEntry[],
    tokens: DetectedToken[],
    options: CodeGenerationOptions
  ): string {
    const codeBlocks: string[] = [];
    const requestTemplate = new GenericRequestTemplate(); // Simplified for now

    if (options.includeAnalysisModeMetadata) {
      codeBlocks.push(this.generateContextualHeader());
    }
    
    criticalPath.forEach(entry => {
        codeBlocks.push(requestTemplate.generateRequestBlock(entry));
    });
    
    // Simplified token and keycheck generation
    tokens.forEach(token => {
        let block = `BLOCK:Parse "${token.name}"\n`;
        if(token.extractionMethod.type === 'regex' && token.extractionMethod.pattern) {
            block += `  type = REGEX\n  pattern = "${token.extractionMethod.pattern}"\n`;
        }
        block += `ENDBLOCK\n\n`
        codeBlocks.push(block);
    });

    if(options.generateValidationBlocks) {
        let keyCheck = `BLOCK:KeyCheck\n  keyChains = {\n`;
        keyCheck += `    SUCCESS = (STATUS, "200")\n`;
        keyCheck += `    FAILURE = (STATUS, "403")\n`;
        keyCheck += `  }\nENDBLOCK\n`
        codeBlocks.push(keyCheck);
    }

    return codeBlocks.join('\n');
  }

  private generateContextualHeader(): string {
    return `
# Generated by HAR2LoliCode Automator
# Analysis Mode: ${this.analysisMode}
# Template Type: ${this.templateType}
# Generated: ${new Date().toISOString()}
# Review and adapt the configuration before use.
`;
  }
}
